
# Расчёт DVH (Dose–Volume Histogram) с параллельной обработкой


---

## Постановка задачи

Имеется 3D-модель, заданная равномерной прямоугольной сеткой из кубических ячеек (вокселей) размера:

\[
N_x \times N_y \times N_z
\]

Каждый воксель характеризуется **одним числом** — значением дозы облучения.

### Формат входных данных

Текстовый файл следующего вида:

1. **Первая строка**: три целых числа

   ```text
   Nx Ny Nz


— количество вокселей по каждому из трёх направлений.

2. **Далее**: столбец значений доз (вещественные числа), по одному или нескольку на строке:

   ```text
   d_1
   d_2
   ...
   d_(Nx * Ny * Nz)
   ```

   Всего должно быть ровно `Nx * Ny * Nz` значений.


### Требуется

Используя файл с дозами, построить зависимость «доза–объём» в процентном виде:

1. Задать шаг по дозе `ΔD` (например, `ΔD = 0.1`).

2. Рассмотреть пороговые значения дозы:

   [
   D = 0,\ \Delta D,\ 2\Delta D,\ 3\Delta D,\ \dots,\ D_{\max},
   ]

   где (D_{\max}) — максимальная доза среди всех вокселей.

3. Для каждого порога D вычислить процент объёма (количество вокселей), получившего дозу **не меньше D**:

   [
   V(D) = \frac{#{\text{вокселей с дозой } \ge D}}{N_x \cdot N_y \cdot N_z} \cdot 100%.
   ]

   Примеры:

   * При (D = 0): все воксели имеют дозу ≥ 0 → (V(0) = 100%).
   * При достаточно большом D, превосходящем все дозы, (V(D) = 0%).

4. Построить график функции (V(D)):

   * Ось X — доза `D`,
   * Ось Y — процент объёма `V(D)`.

---

## Формат решения и структура проекта

Структура репозитория:

```text
.
├── dvh_parallel.py             # Основное решение (последовательное + параллельное)
├── requirements.txt            # Список зависимостей (numpy, matplotlib)
├── README.md                   # Описание (вы этот файл читаете сейчас)
└── data/
    ├── doses_varied_3x3x3.txt      # Тестовый набор данных №1
    └── doses_clustered_3x3x3.txt   # Тестовый набор данных №2
```

---

## Установка и запуск через командную строку

### 1. Установка зависимостей

Рекомендуется использовать виртуальное окружение (`venv`), но можно и глобально.

```bash
pip install -r requirements.txt
```

Файл `requirements.txt`:

```text
numpy
matplotlib
```

### 2. Запуск решения

Общий формат запуска:

```bash
python dvh_parallel.py <путь_к_входному_файлу> -d <ΔD> [опции]
```

Обязательные параметры:

* `input_file` — путь к входному файлу с дозами (формата `Nx Ny Nz` + дозы).
* `-d, --delta` — шаг по дозе `ΔD` (вещественное число > 0).

Дополнительные опции:

* `-o, --output <файл>` — сохранить таблицу `D  V(D)` в текстовый файл.
* `-p, --processes <N>` — задать число процессов для параллельной обработки (по умолчанию: число ядер).
* `--no-plot` — не строить график, только вывести/сохранить таблицу.

### Примеры запуска

1. **Посчитать DVH и показать график** для первого тестового файла:

   ```bash
   python dvh_parallel.py data/doses_varied_3x3x3.txt -d 0.1
   ```

2. **Посчитать DVH, сохранить таблицу в файл и не показывать график**:

   ```bash
   python dvh_parallel.py data/doses_clustered_3x3x3.txt -d 0.1 -o dvh_output.txt --no-plot
   ```

3. **Явно указать число процессов** (например, 4):

   ```bash
   python dvh_parallel.py data/doses_varied_3x3x3.txt -d 0.1 -p 4
   ```

---

## Описание решения

### Чтение данных

Функция `read_doses_from_file`:

1. Считывает первую строку и извлекает `Nx, Ny, Nz`.
2. Рассчитывает ожидаемое число вокселей: `total_voxels = Nx * Ny * Nz`.
3. Считывает оставшиеся строки, парсит вещественные числа в список доз.
4. Проверяет, что количество доз совпадает с `total_voxels`.
5. Возвращает `Nx, Ny, Nz` и массив доз.

### Алгоритм вычисления DVH

1. Считываем все дозы в массив `doses`.

2. Находим максимальную дозу:

   ```python
   D_max = doses.max()
   ```

3. Формируем границы бинов (интервалов по дозе) с шагом `ΔD`:

   ```python
   bin_edges = np.arange(0.0, D_max + delta_D * 1.0001, delta_D)
   D_values = bin_edges[:-1]  # левый край каждого интервала
   ```

4. Считаем гистограмму доз — сколько вокселей попало в каждый бин `[D, D + ΔD)`.

5. Далее из гистограммы строим **накопленную сумму справа** — это даёт количество вокселей с дозой **не ниже** соответствующего порога `D`:

   ```python
   tail_counts = np.cumsum(global_hist[::-1])[::-1]
   ```

6. Преобразуем в проценты:

   ```python
   V_values = tail_counts / total_voxels * 100.0
   ```

### Параллельная часть

Параллельность реализована через модуль `multiprocessing` по схеме **map–reduce**:

1. Массив доз делится на несколько кусков по числу процессов:

   ```python
   chunks = np.array_split(doses, n_processes)
   ```

2. Каждому процессу передаётся своя часть данных и общие границы бинов `bin_edges`.

3. В каждом процессе выполняется `local_histogram(chunk, bin_edges)`, которая считает **локальную гистограмму** для своего куска данных.

4. Главный процесс собирает все локальные гистограммы и суммирует их:

   ```python
   global_hist = np.sum(local_hists, axis=0)
   ```

5. Далее алгоритм превращения гистограммы в DVH (накопленная сумма, проценты) идентичен последовательному.

Преимущества такого подхода:

* Нет гонок данных: каждый процесс работает только со своей копией данных.
* Масштабируемость на больших объёмах: основная нагрузка — проход по массиву доз и построение гистограммы, что хорошо параллелится.

---

## Результаты

Ниже приведены примеры работы программы на двух тестовых файлах из каталога `data/`.

---

### 1. Файл: `data/doses_varied_3x3x3.txt`

**Параметры:**

* Размеры сетки: `Nx = 3`, `Ny = 3`, `Nz = 3`
* Общее число вокселей: `27`
* Минимальная доза: `0.0500`
* Максимальная доза: `2.9100`
* Шаг по дозе: `ΔD = 0.1`

**Таблица `D  V(D)` (в процентах):**

```text
# D     V(D)_percent
0.000000        100.000000
0.100000        96.296296
0.200000        88.888889
0.300000        81.481481
0.400000        74.074074
0.500000        70.370370
0.600000        66.666667
0.700000        62.962963
0.800000        59.259259
0.900000        55.555556
1.000000        48.148148
1.100000        44.444444
1.200000        40.740741
1.300000        40.740741
1.400000        37.037037
1.500000        33.333333
1.600000        29.629630
1.700000        29.629630
1.800000        25.925926
1.900000        22.222222
2.000000        22.222222
2.100000        22.222222
2.200000        18.518519
2.300000        18.518519
2.400000        14.814815
2.500000        11.111111
2.600000        11.111111
2.700000        7.407407
2.800000        3.703704
2.900000        3.703704
```

DVH для этого файла даёт плавный спад, отражающий относительно равномерно «размазанные» значения доз.

---

### 2. Файл: `data/doses_clustered_3x3x3.txt`

**Параметры:**

* Размеры сетки: `Nx = 3`, `Ny = 3`, `Nz = 3`
* Общее число вокселей: `27`
* Минимальная доза: `0.0300`
* Максимальная доза: `2.9200`
* Шаг по дозе: `ΔD = 0.1`

**Таблица `D  V(D)` (в процентах):**

```text
# D     V(D)_percent
0.000000        100.000000
0.100000        88.888889
0.200000        81.481481
0.300000        77.777778
0.400000        74.074074
0.500000        74.074074
0.600000        70.370370
0.700000        66.666667
0.800000        66.666667
0.900000        62.962963
1.000000        59.259259
1.100000        55.555556
1.200000        51.851852
1.300000        48.148148
1.400000        44.444444
1.500000        40.740741
1.600000        40.740741
1.700000        37.037037
1.800000        37.037037
1.900000        33.333333
2.000000        33.333333
2.100000        33.333333
2.200000        29.629630
2.300000        25.925926
2.400000        22.222222
2.500000        18.518519
2.600000        14.814815
2.700000        11.111111
2.800000        3.703704
2.900000        3.703704
```

Здесь дозы сгруппированы (низкие, средние, высокие), поэтому DVH имеет более выраженные «ступеньки», отражающие кластерную структуру распределения доз.

---

## Заключение

Реализованное решение:

* корректно читает 3D-сетку доз из текстового файла;
* вычисляет DVH по заданному шагу `ΔD`;
* использует параллельную обработку через `multiprocessing` для ускорения построения гистограммы;
* позволяет выводить результат в текстовый файл и визуализировать DVH с помощью `matplotlib`.

Проект легко масштабируется на большие объёмы данных (большие `Nx, Ny, Nz`), где параллельность даёт ощутимый выигрыш по времени.

```
```
